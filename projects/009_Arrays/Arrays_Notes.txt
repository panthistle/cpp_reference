ARRAYS


An array is a series of elements of the same type placed in contiguous memory locations that can be individually
referenced by adding an index to a unique identifier.

In c++, the first element in an array is always indexed with zero. Like a regular variable, an array must be declared
before it is used. A typical declaration for an array is:

type name [elements];

where type is a valid type, name is a valid identifier and the elements field specifies the length of the array in
terms of the number of elements.
NOTE:   The elements field within square brackets [], representing the number of elements in the array, must be a
        constant expression, since arrays are blocks of static memory whose size must be determined at compile time,
        before the program runs.


Initializing arrays

By default, regular arrays of local scope (for example, those declared within a function) are left uninitialized.
This means that none of its elements are set to any particular value; their contents are undetermined at that point.

But the elements in an array can be explicitly initialized to specific values when it is declared, by enclosing those
initial values in braces {}. The number of values between braces {} shall not be greater than the number of elements
in the array. If declared with less, the remaining elements are set to their default values (for fundamental types,
this means that they are filled with zeroes).

The initializer may have no values, just the braces, in such cases each element is initialized with a value of zero.

When an initialization of values is provided for an array, c++ allows the possibility of leaving the square brackets
empty []. In this case, the compiler will assume automatically a size for the array that matches the number of values
included between the braces {}.

The evolution of c++ has led to the adoption of universal initialization also for arrays. Therefore, there is no
longer need for the equal sign between the declaration and the initializer. Both these statements are equivalent:

int foo[] = { 10, 20, 30 };
int foo[] { 10, 20, 30 };

Static arrays, and those declared directly in a namespace (outside of functions), are always initialized. If no
explicit initializer is specified, all the elements are default-initialized (with zeroes, for fundamental types).


Accessing the values of arrays

The values of any of the elements in an array can be accessed just like the value of a regular variable of the
same type. The syntax is: name[index]

In c++, it is syntactically correct to exceed the valid range of indices for an array. This can create problems,
since accessing out-of-range elements do not cause errors on compilation, but can cause errors during runtime.

Some valid operations with arrays:

foo[0] = a;     foo[a] = 75;    b = foo [a+2];      foo[foo[a]] = foo[2] + 5;


Multidimensional arrays

Multidimensional arrays can be described as "arrays of arrays". For example, a bi-dimensional array can be imagined
as a two-dimensional table made of elements, all of them of a same uniform data type.

Multidimensional arrays are not limited to two indices (i.e., two dimensions). They can contain as many indices as
needed. Although the amount of memory needed for an array increases exponentially with each dimension.

Multidimensional arrays are just an abstraction for programmers, since the same results can be achieved with a
simple array, by multiplying its indices:

int arr [3][5];   // is equivalent to
int arr [15];     // (3 * 5 = 15)

With the only difference that with multidimensional arrays, the compiler automatically remembers the depth of each
imaginary dimension.


Arrays as parameters

In c++, it is not possible to pass the entire block of memory represented by an array to a function directly as an
argument. What can be passed instead is its address. In practice, this has almost the same effect, and it is a much
faster and more efficient operation.

To accept an array as parameter for a function, the parameter can be declared as the array type, but with empty
brackets, omitting the size of the array. For example:

void procedure (int arg[])

In order to pass to this function an array declared as: int myarray [40];
it would be enough to write a call like this:   procedure (myarray);

In a function declaration, it is also possible to include multidimensional arrays. The format for a tri-dimensional
array parameter is:

base_type[][depth][depth]

A function with a multidimensional array as argument could be:

void procedure (int myarray[][3][4])

Notice that the first brackets [] are left empty, while the following ones specify sizes for their respective
dimensions. This is necessary in order for the compiler to be able to determine the depth of each additional
dimension. In a way, passing an array as argument always loses a dimension. This is because, for historical reasons,
arrays cannot be directly copied, and thus what is really passed is a pointer.


Library arrays

c++ provides an alternative array type as a standard container. It is a type template (a class template, in fact)
defined in header: #include <array>
An array variable may then be declared, for example as: array<int,3> myarray {10,20,30};
This type operates in a similar way to built-in arrays, except that it allows being copied (an expensive operation
that copies the entire block of memory) and it decays into pointer only when explicitly told to do so (by means of
its member data).
